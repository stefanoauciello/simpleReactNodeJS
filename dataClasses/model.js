const Sequelize = require('sequelize');
const faker = require('faker/locale/it');

const sequelize = require('./sequelize');

class Model extends Sequelize.Model {
  /* istanbul ignore next */
  static get modelFields() {
    throw new Error('The static getter "modelFields" must be implemented');
  }

  static get modelOptions() {
    const modelName = this.name;

    return {
      modelName,
      sequelize,
    };
  }

  static async createMock(modelDefault = {}) {
    const model = new this(modelDefault);

    Object.keys(this.rawAttributes).forEach((attributeName) => {
      const attribute = this.rawAttributes[attributeName];

      // eslint-disable-next-line no-underscore-dangle
      if (attribute.allowNull || attribute.defaultValue || attribute._autoGenerated) {
        return;
      }

      if (typeof modelDefault[attributeName] !== 'undefined') {
        return;
      }

      if (attribute.mock) {
        model[attributeName] = attribute.mock();
      } else {
        switch (attribute.type.key) {
          case 'STRING':
          case 'TEXT':
            model[attributeName] = faker.random.alphaNumeric(faker.random.number({ min: 5, max: 15 }));
            break;

          case 'INTEGER':
          case 'DOUBLE PRECISION':
          case 'DOUBLE':
          case 'DECIMAL':
            model[attributeName] = faker.random.number();
            break;

          case 'BOOLEAN':
            model[attributeName] = faker.random.boolean();
            break;

          case 'DATE':
            model[attributeName] = faker.date.future();
            break;

          case 'ENUM':
            model[attributeName] = faker.random.arrayElement(attribute.type.values);
            break;

          case 'VIRTUAL':
            // do nothing
            break;

          case 'BLOB':
            // do nothing
            break;

          case 'JSON':
            // do nothing
            break;

          case 'UUID':
            // do nothing
            break;

            /* istanbul ignore next */
          default:
            throw new Error(`Attribute type not handled: "${attribute.type.key}"`);
        }
      }
    });

    return model.save();
  }

  static async createMocks(targetCount, ...args) {
    return Promise.all([...Array(targetCount).keys()].map(() => this.createMock(...args.map(arg => _.cloneDeep(arg)))));
  }

  static async mock() {
    return this;
  }

  static associate() {
    this.associations = {};

    return this;
  }

  static init() {
    super.init(this.modelFields, this.modelOptions);

    return this;
  }
}

module.exports = { Model };
